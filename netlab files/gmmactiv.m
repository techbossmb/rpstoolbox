function a = gmmactiv(mix, x, options)
%GMMACTIV Computes the activations of a Gaussian mixture model.
%
%	Description
%	This function computes the activations A (i.e. the  probability
%	P(X|J) of the data conditioned on each component density)  for a
%	Gaussian mixture model.  For the PPCA model, each activation is the
%	conditional probability of X given that it is generated by the
%	component subspace. The data structure MIX defines the mixture model,
%	while the matrix X contains the data vectors.  Each row of X
%	represents a single vector.
%
%	See also
%	GMM, GMMPOST, GMMPROB
%

%	Copyright (c) Ian T Nabney (1996-2001)

%	Modifications:
%		V1.0, 07/07/2003, Richard Povinelli, Line numbers: 68-77, tweak the   
%         matrix to make it positive definite to avoid chol error
%		V1.1, 07/15/2003, Sarah Schmit, Line numbers: 35-39, add options(5)
%         as optional input set options(5) = 1 to use v1.0 fix
%		V2.0, 07/29/2003, Richard Povinelli, Line numbers: 86-95, added back 
%         in original chol code
%		V2.1, 12/22/2004, Richard Povinelli, Line numbers: 74-82,
%         modifications to make positive definite search exponential



%sjs: add options as an optional input
if nargin < 3
  options(5) = 0;
end
%end sjs

% Check that inputs are consistent
errstring = consist(mix, 'gmm', x);
if ~isempty(errstring)
  error(errstring);
end

ndata = size(x, 1);
a = zeros(ndata, mix.ncentres);  % Preallocate matrix

switch mix.covar_type
  
case 'spherical'
  % Calculate squared norm matrix, of dimension (ndata, ncentres)
  n2 = dist2(x, mix.centres);
  
  % Calculate width factors
  wi2 = ones(ndata, 1) * (2 .* mix.covars);
  normal = (pi .* wi2) .^ (mix.nin/2);
  
  % Now compute the activations
  a = exp(-(n2./wi2))./ normal;
  
case 'diag'
  normal = (2*pi)^(mix.nin/2);
  s = prod(sqrt(mix.covars), 2);
  for j = 1:mix.ncentres
    diffs = x - (ones(ndata, 1) * mix.centres(j, :));
    a(:, j) = exp(-0.5*sum((diffs.*diffs)./(ones(ndata, 1) * ...
      mix.covars(j, :)), 2)) ./ (normal*s(j));
  end
  
case 'full'
  normal = (2*pi)^(mix.nin/2);
  for j = 1:mix.ncentres
    diffs = x - (ones(ndata, 1) * mix.centres(j, :));
    % Use Cholesky decomposition of covariance matrix to speed computation
    
    if (options(5))    %handle non-positive definite covariance matrices
	    [c p] = chol(mix.covars(:, :, j));
        delta = eps; %initial step size, rjp
	    while p ~= 0 %nonpositive definite
	      dim = length(mix.covars(:, :, j));
	      mix.covars(:, :, j) = mix.covars(:, :, j) + eye(dim)*delta; %rjp
	      [c p] = chol(mix.covars(:, :, j));
        delta = delta * 10; %find positive definite in exponential fashion, rjp
	    end %while
    else %the original way of doing it
      c = chol(mix.covars(:, :, j));
    end
    
    temp = diffs/c;
    a(:, j) = exp(-0.5*sum(temp.*temp, 2))./(normal*prod(diag(c)));
  end
case 'ppca'
  log_normal = mix.nin*log(2*pi);
  d2 = zeros(ndata, mix.ncentres);
  logZ = zeros(1, mix.ncentres);
  for i = 1:mix.ncentres
    k = 1 - mix.covars(i)./mix.lambda(i, :);
    logZ(i) = log_normal + mix.nin*log(mix.covars(i)) - ...
      sum(log(1 - k));
    diffs = x - ones(ndata, 1)*mix.centres(i, :);
    proj = diffs*mix.U(:, :, i);
    d2(:,i) = (sum(diffs.*diffs, 2) - ...
      sum((proj.*(ones(ndata, 1)*k)).*proj, 2)) / ...
      mix.covars(i);
  end
  a = exp(-0.5*(d2 + ones(ndata, 1)*logZ));
otherwise
  error(['Unknown covariance type ', mix.covar_type]);
end
  
